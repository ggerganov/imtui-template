#pragma once

#include <string>
#include <vector>

struct Log {
    std::string username;
    std::string text;
};

const std::vector<Log> kLogs = {
    { "dirbaio[m]"      , R"foo(oh lol and the proxy forwards the logs)foo" },
    { "jschievink"      , R"foo(yeah, that part works surprisingly well)foo" },
    { "dirbaio[m]"      , R"foo(🤯)foo" },
    { "jschievink"      , R"foo(that way users don't have to wait for me to copy the logs over)foo" },
    { "therealprof[m]"  , R"foo(Any chance to get a signoff on the newsletter?)foo" },
    { "dirbaio[m]"      , R"foo(it's somewhat crazy rube-goldberg-esque 😂)foo" },
    { "jschievink"      , R"foo(yeah)foo" },
    { "jschievink"      , R"foo(I'm kinda hoping the blog post makes github engineers terrified of me and fix the runner security issues by themselves)foo" },
    { "dirbaio[m]"      , R"foo(hahahaha)foo" },
    { "jschievink"      , R"foo(then we won't need hacks like this)foo" },
    { "dirbaio[m]"      , R"foo(the runner code is huuuuge, have fun securing that)foo" },
    { "jschievink"      , R"foo(they just need to integrate the small patches rust-lang/rust uses)foo" },
    { "jschievink"      , R"foo(mostly the ability to filter events to not have it run on pull_request events)foo" },
    { "dirbaio[m]"      , R"foo(but what if I do want it to run on PRs?)foo" },
    { "dirbaio[m]"      , R"foo(if it can be properly secured, it's nice that someone can send a PR and get their stuff tested instantly without waiting for any approval)foo" },
    { "jschievink"      , R"foo(you want to grant arbitrary access to hardware?)foo" },
    { "dirbaio[m]"      , R"foo(what's the worst someone could do?)foo" },
    { "jschievink"      , R"foo(brick it, presumably)foo" },
    { "dirbaio[m]"      , R"foo(is it common to be able to brick chips?)foo" },
    { "jschievink"      , R"foo(I would assume so, yeah)foo" },
    { "jschievink"      , R"foo(many chips can disable SWD access)foo" },
    { "dirbaio[m]"      , R"foo(on nrfs you can enable APPROTECT (disables swd debugging) but you can always do the recover operation to erase and unlock the chip)foo" },
    { "jschievink"      , R"foo(you can also short out pins)foo" },
    { "jschievink"      , R"foo(depending on the current the chip can source/sink through GPIOs that might destroy it fairly quickly)foo" },
    { "jschievink"      , R"foo(requires you to mess with alternate functions and such, but you can do it even with no pins physically connected)foo" },
    { "dirbaio[m]"      , R"foo(uh what? you can enable 2 functions on the same pin, then get one to outputlow and the other high at the same time?)foo" },
    { "jschievink"      , R"foo(if you do want the runner to run on PRs then I think some sort of ephemeral VM setup like rust-lang uses would be appropriate)foo" },
    { "dirbaio[m]"      , R"foo(I was thinking of containers..)foo" },
    { "jschievink"      , R"foo(hmm, can you not short them out that way? I suppose there might only be one driver per pin...)foo" },
    { "dirbaio[m]"      , R"foo(no idea)foo" },
    { "jschievink"      , R"foo(containers could also work, but I haven't even figured out how to run the thing as non-root)foo" },
    { "dirbaio[m]"      , R"foo(but that sounds strange coming from the nrf)foo" },
    { "dirbaio[m]"      , R"foo(containers are not secure)foo" },
    { "dirbaio[m]"      , R"foo(CMakeLists.txt LICENSE README.md build cmake logs.h raw raw-all scripts src third-party containers are not as secure)foo" },
    { "dirbaio[m]"      , R"foo(but super fast to start up)foo" },
    { "jschievink"      , R"foo(certainly that STM32 that just has multiple pads bonded to the same pin can be shorted out like that)foo" },
    { "dirbaio[m]"      , R"foo(and no one's going to burn a kernel 0day on hacking some oss project's ci for the lulz)foo" },
    { "jschievink"      , R"foo(I'm currently using this docker image, but it doesn't work https://hub.docker.com/r/myoung34/github-runner)foo" },
    { "dirbaio[m]"      , R"foo(root inside a container is not considered dangerous)foo" },
    { "dirbaio[m]"      , R"foo(what's dangerous is if the container has --privileged)foo" },
    { "jschievink"      , R"foo(is that not equivalent to root outside the container anymore?)foo" },
    { "dirbaio[m]"      , R"foo(anymore? since when has it)foo" },
    { "dirbaio[m]"      , R"foo(CMakeLists.txt LICENSE README.md build cmake logs.h raw raw-all scripts src third-party anymore? when has it been?)foo" },
    { "dirbaio[m]"      , R"foo(what CMakeLists.txt dangerous is mounting `-v /var/run/docker.sock:/var/run/docker.sock`)foo" },
    { "dirbaio[m]"      , R"foo(access to docker.sock is equivalent to root on the host hehe)foo" },
    { "jschievink"      , R"foo(hmm, I thought it was dangerous in general)foo" },
    { "jschievink"      , R"foo(apparently my container knowledge is grossly outdated and/or wrong)foo" },
    { "dirbaio[m]"      , R"foo(ideally the runner would run on the host)foo" },
    { "dirbaio[m]"      , R"foo(and spawn an ephemeral container per job)foo" },
    { "dirbaio[m]"      , R"foo(if you run the runner inside docker it doesn't gain you much security anyway)foo" },
    { "dirbaio[m]"      , R"foo(CMakeLists.txt LICENSE README.md build cmake logs.h raw raw-all scripts src third-party if you run the runner inside the container it doesn't gain you much security anyway)foo" },
    { "dirbaio[m]"      , R"foo(because for example malicious job can steal your runner's credentials)foo" },
    { "dirbaio[m]"      , R"foo(CMakeLists.txt LICENSE README.md build cmake logs.h raw raw-all scripts src third-party because for example a malicious job can steal your runner's credentials)foo" },
    { "jschievink"      , R"foo(it does also spawn containers to run the actions in)foo" },
    { "dirbaio[m]"      , R"foo(but isn't that opt-in?)foo" },
    { "jschievink"      , R"foo(hmm, is it? I thought not)foo" },
    { "jschievink"      , R"foo(ah, maybe jobs that just run a command are ran as-is)foo" },
    { "dirbaio[m]"      , R"foo(https://github.com/akiles/embassy/runs/1914993978?check_suite_focus=true)foo" },
    { "dirbaio[m]"      , R"foo(yeah, echo lol` simply... gets run :D)foo" },
    { "dirbaio[m]"      , R"foo(no ocker)foo" },
    { "dirbaio[m]"      , R"foo(CMakeLists.txt LICENSE README.md build cmake logs.h raw raw-all scripts src third-party no docker)foo" },
    { "dirbaio[m]"      , R"foo(RCE vuln as a service 👌)foo" },
    { "agg"             , R"foo(i wouldn't be surprised if github did notice you)foo" },
    { "agg"             , R"foo(they actively look for CI stuff)foo" },
    { "agg"             , R"foo(https://securitylab.github.com/advisories/GHSL-2020-244-nonebot-nonebot2-workflow)foo" },
    { "agg"             , R"foo(I think what they actually do is search for every workflow using 'pull_request_target', pre-emptively open a security issue, and then double check it's definitely vulnerable)foo" },
    { "jschievink"      , R"foo(oh, cool)foo" },
    { "jschievink"      , R"foo(yeah maybe they automatically flag users for a deeper audit)foo" },
    { "agg"             , R"foo(yea, I think pull_request_target is quite a volatile footgun)foo" },
    { "dirbaio[m]"      , R"foo(hm, but)foo" },
    { "dirbaio[m]"      , R"foo(so the actions (steps with blah`) run sandboxed separately from steps with `run: blah`?)foo" },
    { "jschievink"      , R"foo(I thought so, but the more I look into this the less I understand it)foo" },
    { "dirbaio[m]"      , R"foo(so if you give your github token to one of these actions, it's still supposed to be safe from evil code?)foo" },
    { "jschievink"      , R"foo(maybe I just made that up for some reason)foo" },
    { "jschievink"      , R"foo(I read something about nested containers though)foo" },
    { "dirbaio[m]"      , R"foo(welp that must be the special sauce in their cloud runners)foo" },
    { "dirbaio[m]"      , R"foo(selfhosted runners is "just run shit on the host yolo")foo" },
    { "jschievink"      , R"foo(the cloud runners run in ephemeral VMs from what I know)foo" },
    { "agg"             , R"foo(I don't believe actions run separately to plain steps)foo" },
    { "agg"             , R"foo(or at least, they share the same filesystem?)foo" },
    { "dirbaio[m]"      , R"foo(yea they do)foo" },
    { "dirbaio[m]"      , R"foo(that's why I don't get what the vuln is)foo" },
    { "jschievink"      , R"foo(maybe I was thinking of gitlab? where you do actually specify a docker image)foo" },
    { "jschievink"      , R"foo(not sure anymore :D)foo" },
    { "agg"             , R"foo(gitlab's ci seems much more sane and amenable to these things)foo" },
    { "dirbaio[m]"      , R"foo(yeah on gitlab you do specify image for steps)foo" },
    { "agg"             , R"foo(which vuln?)foo" },
    { "agg"             , R"foo(the one I linked?)foo" },
    { "dirbaio[m]"      , R"foo(yeah)foo" },
    { "agg"             , R"foo(anyone who opens a PR can run arbitrary code in your CI)foo" },
    { "dirbaio[m]"      , R"foo(like)foo" },
    { "agg"             , R"foo(including leaking your secrets)foo" },
    { "agg"             , R"foo(which they can then use to impersonate your.. github account?)foo" },
    { "agg"             , R"foo(or the github repo anyway)foo" },
    { "dirbaio[m]"      , R"foo(yeah, but why can't they do that writing custom ` steps anyway?)foo" },
    { "agg"             , R"foo(it wouldn't get run)foo" },
    { "dirbaio[m]"      , R"foo(why)foo" },
    { "agg"             , R"foo(github does not typically execute workflow code from a pull request)foo" },
    { "agg"             , R"foo(uh)foo" },
    { "agg"             , R"foo(in an environment with secrets, I mean)foo" },
    { "jschievink"      , R"foo(`pull_request` triggers do not get any secrets)foo" },
    { "agg"             , R"foo(when a PR triggers a CI run, no secrets are available to that CI execution)foo" },
    { "jschievink"      , R"foo(and also no privileged `GITHUB_TOKEN`)foo" },
    { "agg"             , R"foo(when using pull_request_target instead, the secrets are available, but it uses the PR's _base_ branch to load the workflow)foo" },
    { "agg"             , R"foo((and ignores the PR's workflow files))foo" },
    { "dirbaio[m]"      , R"foo(okay so ` stuff runs with no secrets, but that `nonebot` action does run with secrets?)foo" },
    { "dirbaio[m]"      , R"foo(aaaaaaaah *that's* the key I was missing)foo" },
    { "jschievink"      , R"foo(whether you have or don't have secrets is a property of the whole workflow run)foo" },
    { "jschievink"      , R"foo(either all steps and jobs have them, or none do)foo" },
    { "agg"             , R"foo(yea)foo" },
    { "agg"             , R"foo(and for a normal pull_request, no secrets but the PR's workflow file is run, for a pull_request_target, you get secrets, and use the repo's existing workflow)foo" },
    { "agg"             , R"foo(the vuln is that the PR could include content that caused the repo's existing workflow to run arb code)foo" },
    { "dirbaio[m]"      , R"foo(I see, so it's not for testing code in the PR)foo" },
    { "dirbaio[m]"      , R"foo(it's for doing automation shit like labeling and assigning people)foo" },
    { "dirbaio[m]"      , R"foo(and it runs with the yaml and code from master)foo" },
    { "agg"             , R"foo(yea)foo" },
    { "agg"             , R"foo(e.g. in stm32-rs I use it to push to the mmaps repo and add a comment with a link)foo" },
    { "dirbaio[m]"      , R"foo(and the vuln is that action running from master is explicitly checking out the pr's code and running it)foo" },
    { "agg"             , R"foo(but pushing to that repo requires a secret (a repo key) and leaving a comment requires GITHUB_TOKEN)foo" },
    { "dirbaio[m]"      , R"foo(yeaaaah)foo" },
    { "dirbaio[m]"      , R"foo(makes sense)foo" },
    { "agg"             , R"foo(yea)foo" },
    { "agg"             , R"foo(github recommend you do not check out the PR's code, ideally)foo" },
    { "agg"             , R"foo(but if you do check it out, don't run code from it)foo" },
    { "agg"             , R"foo(they suggest you use the PR's CI to trigger a second CI job that runs in the repo context instead of using pull_request_target, but it's not clear to me how much that helps really)foo" },
    { "agg"             , R"foo(a bit, maybe)foo" },
    { "agg"             , R"foo(if your CI ultimately involves like, building the submitted PR, it's probably game over)foo" },
    { "agg"             , R"foo(in stm32-rs I pull in the inert yaml from the PR, svdtools uses yaml.safe_load to avoid that hilarity, so unless you can get code execution from a yaml file it should be ok, but)foo" },
    { "agg"             , R"foo(you probably can get code execution from yaml, lol, yaml's a mess)foo" },
    { "agg"             , R"foo(originally it also happened to copy extract.sh which unzips the vendor svd zip files, which would have also been game over if some PR added lols to extract.sh)foo" },
    { "dirbaio[m]"      , R"foo(heheeee 😈)foo" },
    { "agg"             , R"foo(very 'sausage factory', don't look too close)foo" },
    { "dirbaio[m]"      , R"foo(microsoft loves their uuids 😤)foo" },
    { "agg"             , R"foo(i wonder if you could use 'bors try' to make it work ok)foo" },
    { "agg"             , R"foo(bors is able to push to the trying branch, you can have a CI workflow on push:trying which would get secrets)foo" },
    { "agg"             , R"foo(only authorised users can trigger 'bors try')foo" },
    { "agg"             , R"foo(anyway doesn't help with the custom runner directly because it would still run all the other PRs, heh)foo" },
    { "jschievink"      , R"foo(yeah, that's basically what I'm relying on right now)foo" },
    { "dirbaio[m]"      , R"foo(also, no websockets, just http long polling. And lots of POSTs to upload logs 🤯)foo" },
    { "dirbaio[m]"      , R"foo(it doesn't seem THAT bad though)foo" },
    { "dirbaio[m]"      , R"foo(it seems feasible to me to implement some subset that supports only `run` steps)foo" },
    { "dirbaio[m]"      , R"foo(enforcing non-privileged container per job)foo" },
    { "agg"             , R"foo(a non-priv container... that can still access the HIL you have attached?)foo" },
    { "agg"             , R"foo(I guess maybe you could add a list of users allowed to trigger jobs and just not run any from unknown users?)foo" },
    { "dirbaio[m]"      , R"foo(I think you can mount just one usb device)foo" },
    { "agg"             , R"foo(e.g. allow all repo/org members to run jobs right away, somehow require approval for others? idk)foo" },
    { "agg"             , R"foo(at this point it might be easier to just build a webhook that receives comments/prs from github api and then fetches the relevant code, the downside is not getting to use github yaml actions)foo" },
    { "agg"             , R"foo(but if you're writing your own runner anyway.....)foo" },
    { "agg"             , R"foo((e.g. your own self hosted bors, but it does hil testing))foo" },
    { "dirbaio[m]"      , R"foo(yeah reimplementing a runner is probably stupid)foo" },
    { "dirbaio[m]"      , R"foo(the nice thing is it'd reuse the GHA UI)foo" },
    { "dirbaio[m]"      , R"foo(otherwise you'd have to have some UI so users can see the logs)foo" },
    { "agg"             , R"foo(yea, true)foo" },
    { "dirbaio[m]"      , R"foo(but at that point installing something like drone is maybe easier)foo" },
    { "agg"             , R"foo(hmm)foo" },
    { "agg"             , R"foo(or gitlab I guess)foo" },
    { "agg"             , R"foo(you could probably set up gitlab to run only approved PRs from github, but make the logs public)foo" },
    { "dirbaio[m]"      , R"foo(external ci is not available on gitlab free anymore)foo" },
    { "agg"             , R"foo(ah)foo" },
    { "agg"             , R"foo(i guess you could DIY that part with a script that gets github api events and triggers gitlab api events, but meh)foo" },
    { "dirbaio[m]"      , R"foo(meh indeed)foo" },
    { "dirbaio[m]"      , R"foo(and they switched drone to a freemium license where the OSS version is very restricted :P)foo" },
    { "agg"             , R"foo(of course)foo" },
    { "agg"             , R"foo(gotta get that big corp megabucks I guess)foo" },
    { "dirbaio[m]"      , R"foo(yep everyone's trying to extract money like crazy from CI stuff)foo" },
    { "agg"             , R"foo(I can only assume someone's paying for it)foo" },
    { "dirbaio[m]"      , R"foo(you could say even github itself doesn't want their selfhosted runner to be "too good" so they can sell you more actions minutes)foo" },
    { "agg"             , R"foo(at least they'll sell you them by the minute I guess)foo" },
    { "agg"             , R"foo(Travis...)foo" },
    { "dirbaio[m]"      , R"foo(you're compiling the C code to a .a then linking everything from Rust?)foo" },
    { "dirbaio[m]"      , R"foo(you're probably missing linking with a libc)foo" },
    { "i_am_the_carl[m]", R"foo(That would make sense... hold on I think the cc crate had something for that.)foo" },
    { "i_am_the_carl[m]", R"foo(Hmm, I guess the CC crate didn't have that.)foo" },
    { "i_am_the_carl[m]", R"foo(Actually this may do the job.)foo" },
    { "i_am_the_carl[m]", R"foo(https://crates.io/crates/tinyrlibc)foo" },
    { "i_am_the_carl[m]", R"foo(In the end I couldn't get that working ether, but found a way to disable the feature in FreeRTOS that required the strlen function.)foo" },
    { "therealprof[m]"  , R"foo(The annoying part of GHA is really the completely lackluster documentation, I don't even want to know how many hours we burned to figure out how it works.)foo" },
    { "korken89[m]"     , R"foo(The trait is only used to do weird pointer stuff in the background)foo" },
    { "korken89[m]"     , R"foo(And there are 2 cases that need to be handled, slices and non-slices in this case...)foo" },
    { "chrysn[m]"       , R"foo(i *think* you can use any's downcast functionality even when you're not in a `dyn Any` situation)foo" },
    { "korken89[m]"     , R"foo(Can it detect slices?)foo" },
    { "korken89[m]"     , R"foo(I think you need if statements for each slice type then)foo" },
    { "chrysn[m]"       , R"foo(oh so you mean any kind of slice ... that sounds harder)foo" },
    { "Lumpio-"         , R"foo(Aren't all the Any functions implemented for dyn Any only tho)foo" },
    { "korken89[m]"     , R"foo(I sort of would have expected this to work)foo" },
    { "korken89[m]"     , R"foo(https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=0924d9c3bfab41d9f3f0d7ac5a3cd058)foo" },
    { "chrysn[m]"       , R"foo(you're right, they're just implemented for `dyn Any`; however, when a function is generic, a locally created dynamically typed thing might be optimzied out right away.)foo" },
    { "korken89[m]"     , R"foo(Oh it was a small error)foo" },
    { "korken89[m]"     , R"foo(This https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=71bead2df403c018c26dd24e4bcec1ef)foo" },
    { "korken89[m]"     , R"foo(:D)foo" },
    { "chrysn[m]"       , R"foo(yay :-))foo" },
    { "korken89[m]"     , R"foo(I was 100% sure this would require specialization)foo" },
    { "chrysn[m]"       , R"foo(probably it's only specialization if there's any chance something might fit both (and [T] and &T are mutually exclusive))foo" },
    { "korken89[m]"     , R"foo(Seems so)foo" },
    { "korken89[m]"     , R"foo(Hmm, turned out to get a unified interface though was difficult)foo" },
    { "korken89[m]"     , R"foo(`print_is_slice(&a)` and `print_is_slice(&b)`)foo" },
    { "korken89[m]"     , R"foo(One now needs to do `print_is_slice(&a)` and `print_is_slice(b)`)foo" },
    { "korken89[m]"     , R"foo(And changing one of the impls to add/remove `&` in the type causes the implementations to collide)foo" },
    { "chrysn[m]"       , R"foo(maybe you can have a default implementation in the trait (that says "is-slice = no", and then have one implementation `for T where IsActuallySlice` that overrides it to say is-slice = yes?)foo" },
    { "korken89[m]"     , R"foo(Hmm)foo" },
    { "korken89[m]"     , R"foo(Could you make an example? I am not quite following)foo" },
    { "chrysn[m]"       , R"foo(just on it)foo" },
    { "korken89[m]"     , R"foo(Thanks! :D)foo" },
    { "dirbaio[m]"      , R"foo(without specialization? O_o)foo" },
    { "korken89[m]"     , R"foo(Indeed)foo" },
    { "korken89[m]"     , R"foo(I want it on stable :))foo" },
    { "korken89[m]"     , R"foo(Else I need to solve it via a proc-macro)foo" },
    { "korken89[m]"     , R"foo(And that will suck :P)foo" },
    { "dirbaio[m]"      , R"foo(not sure that's possible)foo" },
    { "korken89[m]"     , R"foo(We are trying to get printing of slices to work in `dwarffmt`)foo" },
    { "korken89[m]"     , R"foo(And either I do it via a trait, or via the proc-macro that parses the formating string, and then we need a marker for slices instead)foo" },
    { "chrysn[m]"       , R"foo(hmpf, no -- that boils down to just the same issue :-()foo" },
    { "dirbaio[m]"      , R"foo(I don't get why does the code you linked even work)foo" },
    { "korken89[m]"     , R"foo(Magic 🪄)foo" },
    { "korken89[m]"     , R"foo(:()foo" },
    { "dirbaio[m]"      , R"foo(why does it with work with `for &T` but not with `for T`)foo" },
    { "chrysn[m]"       , R"foo(trying again with the &dyn Any approach...)foo" },
    { "korken89[m]"     , R"foo(I have no idea haha)foo" },
    { "korken89[m]"     , R"foo(But it does work :D)foo" },
    { "korken89[m]"     , R"foo(How far away is specialization now again? 😅)foo" },
    { "dirbaio[m]"      , R"foo(aaaah)foo" },
    { "dirbaio[m]"      , R"foo(it's implicitly Sized)foo" },
    { "korken89[m]"     , R"foo(N+1 years, where N is any integer?)foo" },
    { "dirbaio[m]"      , R"foo(and [T] is not Sized, so the impls don't overlap)foo" },
    { "korken89[m]"     , R"foo(Oh)foo" },
    { "korken89[m]"     , R"foo(Sneaky)foo" },
    { "chrysn[m]"       , R"foo(i mean there's always this https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=71bead2df403c018c26dd24e4bcec1ef)foo" },
    { "dirbaio[m]"      , R"foo(IsSlice for &T` then they conlict too)foo" },
    { "chrysn[m]"       , R"foo(is this about debugging (evaluating ELF files with DWARF) or about a very small formatter?)foo" },
    { "korken89[m]"     , R"foo(very small formatter using DWARF)foo" },
    { "korken89[m]"     , R"foo(Think defmt)foo" },
    { "korken89[m]"     , R"foo(But DWARF based)foo" },
    { "chrysn[m]"       , R"foo(ah ... but then it's about the (non-embedded) expansion step?)foo" },
    { "korken89[m]"     , R"foo(Ah no, we need to detect when performing the print on the MCU if it is a slice)foo" },
    { "korken89[m]"     , R"foo(So we send the entire slice and not just the ptr and len)foo" },
    { "korken89[m]"     , R"foo(And I can do it via the proc macro)foo" },
    { "korken89[m]"     , R"foo(Like `log("Hello {:s}", &my_slice)`)foo" },
    { "korken89[m]"     , R"foo(Where `:s` indicates a slice)foo" },
    { "korken89[m]"     , R"foo(And generate special code for it)foo" },
    { "korken89[m]"     , R"foo(But I'd like to not do that if possible)foo" },
    { "dirbaio[m]"      , R"foo(what about slices in struct fields?)foo" },
    { "dirbaio[m]"      , R"foo(how'd you do that without a derive?)foo" },
    { "chrysn[m]"       , R"foo(understandable. (and btw, that'd be great to use, i just implemented a terrible remote log viewer via CoAP, and i'd like to do it right and this sounds like the way to go))foo" },
    { "korken89[m]"     , R"foo(Currently not supported)foo" },
    { "korken89[m]"     , R"foo(For that one would need a derive)foo" },
    { "korken89[m]"     , R"foo(The idea of `dwarffmt` is not to replace `defmt`)foo" },
    { "korken89[m]"     , R"foo(They have different usecases)foo" },
    { "korken89[m]"     , R"foo(Preferable one would have both)foo" },
    { "korken89[m]"     , R"foo(If you don't have special derives, fall back to `dwarffmt`)foo" },
    { "chrysn[m]"       , R"foo(did you check the last link? maybe that's already good enough if the compiler is smart (it's a crude hack, though -- and works))foo" },
    { "korken89[m]"     , R"foo(Which allows you to print types you do not own for example)foo" },
    { "dirbaio[m]"      , R"foo(hehe more specialization :D)foo" },
    { "korken89[m]"     , R"foo(The worst thing I know is to print something I first need to vendor the lib)foo" },
    { "korken89[m]"     , R"foo(Add defmt or whatever)foo" },
    { "korken89[m]"     , R"foo(Use that)foo" },
    { "korken89[m]"     , R"foo(Then it works, remove it all)foo" },
    { "korken89[m]"     , R"foo(Then it breaks again)foo" },
    { "korken89[m]"     , R"foo(Vendor again)foo" },
    { "korken89[m]"     , R"foo(....)foo" },
    { "korken89[m]"     , R"foo(Or I could just print utilizing DWARF)foo" },
    { "korken89[m]"     , R"foo(If GDB can print it, why not us?)foo" },
    { "dirbaio[m]"      , R"foo(ah yea, soooo annoying, did that with smoltcp)foo" },
    { "dirbaio[m]"      , R"foo(there's Debug2Format and Display2Format btw)foo" },
    { "dirbaio[m]"      , R"foo(you get the fmt strings bloat but maybe for dev it's OK)foo" },
    { "chrysn[m]"       , R"foo(next working general-but-ugly recognition, plus working sane-but-type-specific recognition in https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=2563f12a39c023e1c06eaf1e6cdb1e9a)foo" },
    { "korken89[m]"     , R"foo(Cool)foo" },
    { "dirbaio[m]"      , R"foo(string ops on type_name 🤯)foo" },
    { "korken89[m]"     , R"foo(Haha)foo" },
    { "korken89[m]"     , R"foo(Brb lunch here now :))foo" },
    { "chrysn[m]"       , R"foo(for the third and final stage i'm trying to pull in the IsSlice trait, now that it works with concrete types)foo" },
    { "dirbaio[m]"      , R"foo(it's deliciously horrifying 👌)foo" },
    { "korken89[m]"     , R"foo(I'll see what you come up with!)foo" },
    { "korken89[m]"     , R"foo(Worst case it do it in the proc-macro and away specialization :))foo" },
    { "korken89[m]"     , R"foo(CMakeLists.txt LICENSE README.md build cmake logs.h raw raw-all scripts src third-party Worst case it do it in the proc-macro and await specialization :))foo" },
    { "chrysn[m]"       , R"foo(mh, i'm afraid, no luck :-()foo" },
    { "chrysn[m]"       , R"foo(documenting roads that didn't work https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=9d5c7d28697b4e620c73ddff2eaafff4)foo" },
    { "chrysn[m]"       , R"foo(all boils down to needing specialization.)foo" },
    { "korken89[m]"     , R"foo(mh, i'm afraid, no luck :-()foo" },
    { "korken89[m]"     , R"foo(documenting roads that didn't work https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=9d5c7d28697b4e620c73ddff2eaafff4)foo" },
    { "korken89[m]"     , R"foo(Thanks for testing!)foo" },
    { "wucke13[m]"      , R"foo(Is there any convenient way to create null terminated static string literals in `no_std`?)foo" },
    { "jschievink"      , R"foo(https://docs.rs/cstr/0.2.8/cstr/ works fairly well for this)foo" },
    { "wucke13[m]"      , R"foo(But then I would always have to write ` CString::new("data data data data").unwrap()`, correct?)foo" },
    { "jschievink"      , R"foo(`cstr!` expands to a `&CStr`)foo" },
    { "jschievink"      , R"foo(so I don't think you'd have to do that)foo" },
    { "chrysn[m]"       , R"foo(and especially, `cstr!` makes sure the null is there from the beginning and can be used from static memory)foo" },
    { "chrysn[m]"       , R"foo((so `cstr!("foo")` expands to something like `wrapper("foo0")`.))foo" },
    { "wucke13[m]"      , R"foo(But is `cstr!` `no_std` compatible?)foo" },
    { "jschievink"      , R"foo(looks like no)foo" },
    { "jschievink"      , R"foo(right, the entire `CStr` / `CString` stuff is libstd-only)foo" },
    { "wucke13[m]"      , R"foo(Hmmh, that's kind of a bummer. Wouldn't it have made sense to include at least a literal type for this? Something like `b0"Some string which will be null terminated"`?)foo" },
    { "wucke13[m]"      , R"foo(CMakeLists.txt LICENSE README.md build cmake logs.h raw raw-all scripts src third-party Hmmh, that's kind of a bummer. Wouldn't it have made sense to include at least a literal type for this? Something like `b0"Some string which will be null terminated"`? But then again one could also type `b"Something something0"`, I see.)foo" },
    { "jschievink"      , R"foo(do you just want a `&str` that's null-terminated?)foo" },
    { "chrysn[m]"       , R"foo(are you sure? i'm using a local copy for legacy reasons, but that's no_std)foo" },
    { "jschievink"      , R"foo(it expands to `::std` paths)foo" },
    { "chrysn[m]"       , R"foo(hmpf, right, it i copied it out of std to get it no_std :-/)foo" },
    { "chrysn[m]"       , R"foo(https://docs.rs/cstr_core/0.2.2/cstr_core/)foo" },
    { "chrysn[m]"       , R"foo(it doesn't have a `cstr!()` macro, though (yet? https://github.com/Amanieu/cstr_core/issues/18))foo" },
    { "chrysn[m]"       , R"foo(the advantage `cstr!("foo")` over `b"foo0" is that there is type-level information on the presence of the trailing zero, so a function that passes it on to C can use it safely without an extra check for whether there's a 0 before the end of the [u8].)foo" },
    { "thalesfragoso[m]", R"foo(how can I create an array with a const generic size if the element doesn't implement copy ? it seems like `Default::default()` doesn't work)foo" },
    { "dirbaio[m]"      , R"foo(Stick the element in a const)foo" },
    { "thalesfragoso[m]", R"foo(and if I can't make the new const ?)foo" },
    { "dirbaio[m]"      , R"foo(Then you can't i think...)foo" },
    { "dirbaio[m]"      , R"foo(You can initialize item by item with MaybeUninit lol)foo" },
    { "thalesfragoso[m]", R"foo(Damn, that is just to not use a constant size of 3 for the alarm state, since some timers will only have 1)foo" },
    { "thalesfragoso[m]", R"foo(I'm inclined to just always create 3)foo" },
    { "thalesfragoso[m]", R"foo(and return None in the get_alarm methods)foo" },
    { "dirbaio[m]"      , R"foo(Why can't alarm new be const?)foo" },
    { "thalesfragoso[m]", R"foo(function pointers)foo" },
    { "thalesfragoso[m]", R"foo(hmm, maybe there is a nightly feature for that)foo" },
    { "dirbaio[m]"      , R"foo(even if none?)foo" },
    { "thalesfragoso[m]", R"foo(yep, but I found the feature)foo" },
    { "dirbaio[m]"      , R"foo(huh)foo" },
    { "thalesfragoso[m]", R"foo(const_fn_fn_ptr_basics)foo" },
    { "dirbaio[m]"      , R"foo(alternatively transmute to/from usize lolol)foo" },
    { "thalesfragoso[m]", R"foo(do you think it's worth it ? the users will need to specify the number of alarms in the type)foo" },
    { "dirbaio[m]"      , R"foo(probably not haha, was half-joking)foo" },
    { "dirbaio[m]"      , R"foo(just use moar nightly features)foo" },
    { "thalesfragoso[m]", R"foo(I mean even with the feature)foo" },
    { "dirbaio[m]"      , R"foo(ah, hmm)foo" },
    { "thalesfragoso[m]", R"foo(the users will have to place a 3 or a 1 in the type depending on the timer)foo" },
    { "dirbaio[m]"      , R"foo(can't it be an associated const of the Instance trait? so it picks the right one)foo" },
    { "dirbaio[m]"      , R"foo(CMakeLists.txt LICENSE README.md build cmake logs.h raw raw-all scripts src third-party can't it be an associated const of the Instance trait? so it picks the right one automatically)foo" },
    { "thalesfragoso[m]", R"foo(first I tried with the associate constant, but it can't be placed as an array size)foo" },
    { "thalesfragoso[m]", R"foo(array sizes get resolved before that, so it doesn't recognize it)foo" },
    { "dirbaio[m]"      , R"foo(wot)foo" },
    { "thalesfragoso[m]", R"foo(that's why you need const generics....)foo" },
    { "thalesfragoso[m]", R"foo(otherwise generic_array would be completely different)foo" },
    { "dirbaio[m]"      , R"foo(hm but it's an associated const)foo" },
    { "dirbaio[m]"      , R"foo(constant expression depends on a generic parameternthis may fail depending on what value the parameter takes)foo" },
    { "dirbaio[m]"      , R"foo(hmmmmmm)foo" },
    { "dirbaio[m]"      , R"foo(you can with MOAR nightly magic)foo" },
    { "dirbaio[m]"      , R"foo(https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=08988638d650b38f9b4eea2bdd8d06ee)foo" },
    { "dirbaio[m]"      , R"foo(but maybe that's too much?)foo" },
    { "thalesfragoso[m]", R"foo(maybe ? two more nightly features for that, should we ?)foo" },
    { "dirbaio[m]"      , R"foo(yeah but these are the "warning this is unfinished and may crash the compiler or eat your cat" ones)foo" },
    { "thalesfragoso[m]", R"foo(oh, yeah, I didn't know those ones also have the warning)foo" },
    { "thalesfragoso[m]", R"foo(ok, it's decided, it's gonna be 3 for everyone)foo" },
    { "dirbaio[m]"      , R"foo(maybe do .take_alarm(n) and panic at runtime if `n >= T::ALARM_COUNT`?)foo" },
    { "thalesfragoso[m]", R"foo(I already return an Option)foo" },
    { "thalesfragoso[m]", R"foo(and do that)foo" },
    { "dirbaio[m]"      , R"foo(it's somewhat better than giving an alarm that doesn't work at all to the user)foo" },
    { "dirbaio[m]"      , R"foo(ah okay, so the array will always have 3, but if the timer has only 1 then take of alarms 2,3 will always return none?)foo" },
    { "thalesfragoso[m]", R"foo(yep)foo" },
    { "dirbaio[m]"      , R"foo(nais)foo" },
    { "dirbaio[m]"      , R"foo(just a tiny bit of wasted ram, can optimize later)foo" },
    { "dirbaio[m]"      , R"foo(👍️)foo" },
    { "amber[m]"        , R"foo(So I theoretically have CMSIS-DAP firmware installed on a WeAct blackpill)foo" },
    { "amber[m]"        , R"foo(But cargo flash says no probes detected ;()foo" },
    { "amber[m]"        , R"foo(one sec)foo" },
    { "amber[m]"        , R"foo(yeah)foo" },
    { "agg"             , R"foo(what operating system?)foo" },
    { "agg"             , R"foo(this is often just a driver issue)foo" },
    { "amber[m]"        , R"foo(linux)foo" },
    { "agg"             , R"foo(or permissions issue on linux)foo" },
    { "amber[m]"        , R"foo(thats what I considered)foo" },
    { "agg"             , R"foo(if you run `dmesg` does it say anything about the cmsis-dap at the end?)foo" },
    { "amber[m]"        , R"foo(I will check)foo" },
    { "amber[m]"        , R"foo(it does)foo" },
    { "agg"             , R"foo(create /etc/udev/rules.d/99-cmsis-dap.rules)foo" },
    { "agg"             , R"foo(write ATTRS{product}=="*CMSIS-DAP*", MODE="660", GROUP="plugdev", TAG+="uaccess")foo" },
    { "agg"             , R"foo(sudo udevadm control --reload)foo" },
    { "amber[m]"        , R"foo(okay thats progress)foo" },
    { "agg"             , R"foo(that's a harder one to guess)foo" },
    { "agg"             , R"foo(could be a lot of things. likely candidates bad/wrong connection between probe and target, target not powered, target debug port disabled (maybe it's in sleep or firmware remapped the io pins or...))foo" },
    { "agg"             , R"foo(you should have gnd, swdio, and swclk connected between probe and target, and both probe and target should be powered)foo" },
    { "amber[m]"        , R"foo(I have it working know)foo" },
    { "amber[m]"        , R"foo(CMakeLists.txt LICENSE README.md build cmake logs.h raw raw-all scripts src third-party I have it working now)foo" },
    { "amber[m]"        , R"foo(the weact stuff lead me astray)foo" },
    { "amber[m]"        , R"foo(Thank you for the help :D)foo" },
    { "agg"             , R"foo(nice!)foo" },
    { "agg"             , R"foo(no problem)foo" },
    { "yatekii[m]"      , R"foo(what was the issue? :) also do you run off master or crates?)foo" },
    { "amber[m]"        , R"foo(power stuff)foo" },
    { "amber[m]"        , R"foo(but I think its actually not working)foo" },
    { "amber[m]"        , R"foo(but only pretending to lmao)foo" },
    { "yatekii[m]"      , R"foo(haha)foo" },
    { "yatekii[m]"      , R"foo(how do you figure?)foo" },
    { "amber[m]"        , R"foo(well)foo" },
    { "amber[m]"        , R"foo(I just have a feeling I guess)foo" },
    { "amber[m]"        , R"foo(Right now is my break from programming so who knwos)foo" },
    { "yatekii[m]"      , R"foo(:D)foo" },
    { "gitlabhater"     , R"foo(That is this message 「422)foo" },
    { "gitlabhater"     , R"foo(The change you requested was rejected.)foo" },
    { "gitlabhater"     , R"foo(Make sure you have access to the thing you tried to change.)foo" },
    { "gitlabhater"     , R"foo(Please contact your GitLab administrator if you think this is a mistake.」)foo" },
    { "gitlabhater"     , R"foo(I don't understand... I just try to login with root account.)foo" },
    { "gitlabhater"     , R"foo(【The change you requested was rejected.】← It mean Change Password web page ??  I (root) have no right to access this page !??)foo" },
    { "gitlabhater"     , R"foo(WHY This Stupid App have So Many Bugsssssss... ?  Lots bugs had meet long time ago.)foo" },
    { "adhoc"           , R"foo(it is big and complex?)foo" },
    { "binux"           , R"foo(Is there a tool or way to migrate a gitlab project including PRs and feature branches to github?)foo" },
    { "DJ-ArcAngel"     , R"foo(doesn't github have same import features as gitlab, because then it's build in)foo" },
    { "binux"           , R"foo(DJ-I couldnt find one)foo" },
    { "luc4"            , R"foo(Hello! For unknown reasons, I found out that my GitLab db is corrupted in its schema. What could be a good way to import all data into a fresh db? Import/export of each project? Or is there a better (quicker) alternative?)foo" },
    { "Underknowledge"  , R"foo(@luc4 that depends on what you did to it. easyes always, restore a working backup)foo" },
    { "Underknowledge"  , R"foo(you ll find some help here https://docs.gitlab.com/ce/development/database_debugging.html and I remeber a thread in the forum)foo" },
    { "Underknowledge"  , R"foo(@gitlabhater try to delete your cookies, and just probably a PICNIC issue)foo" },
    { "luc4"            , R"foo(unfortunately the db broke in its schema, and I have no way to know when this happened. The result is that migrations sometimes fail. The broken db makes postgresql segfault. I already fixed the schema twice, now I guess it is time to give up. So I’d need to migrate my instance to a fresh db somehow, so that the schema is not broken anymore.)foo" },
    { "luc4"            , R"foo(I have backups, but it is very difficult to know when the mess happened, and may have happened months and months ago, without me noticing anything.)foo" },
    { "Underknowledge"  , R"foo(when you want to nulke the db and start a new one you can do ''' gitlab-rake db:drop db:create'''')foo" },
    { "luc4"            , R"foo(ok, but the would clear the content as well right?)foo" },
    { "Underknowledge"  , R"foo(followed by an gitlab-ctl reconfigure, should clean out the whole thing)foo" },
    { "luc4"            , R"foo(and then how could I reimport data?)foo" },
    { "luc4"            , R"foo(each project one by one?)foo" },
    { "luc4"            , R"foo(it’s the best I could find)foo" },
    { "Underknowledge"  , R"foo(that should be in database_debugging, I only dropped the DB one time to get a backup back in. so youre there on your own sadly)foo" },
    { "luc4"            , R"foo(and what is the difference of recreating the db like that and creating a new instance from scratch?)foo" },
    { "Underknowledge"  , R"foo(well, I had a recent backup I just played back in. so I had then a working instance. When you good to start a new instance then just do that.)foo" },
    { "Unode"           , R"foo(Hi everyone, I have a .template that contains a - target-One and a build stage that uses extends: .template but also defines a needs: - target-Two. Is there any way to have the build stage include both target-One and target-Two as needs: instead of overwriting the template? Currently the build ends up with needs: target-Two)foo" },
    { "Unode"           , R"foo(also, is there any service that can be used to see the final rendered gitlab-ci.yml file after all templating is logic is interpreted?)foo" },
    { "luc4"            , R"foo(Hello! Anyone who knows if a backup/restore procedure re-uses the database schema of the backup or if only database data are added to the new database?)foo" },
    { "ToM`"            , R"foo(I suppose you could check for any « CREATE TABLE » statements)foo" },
    { "luc4"            , R"foo(in the backup you mean?)foo" },
    { "ToM`"            , R"foo(open .gitlab-ci.yml from the web UI ; there is a tab « View merged YAML » - a quite young feature, one or two releases old I think)foo" },
    { "ToM`"            , R"foo(yep)foo" },
    { "luc4"            , R"foo(from what I see here https://copdips.com/2018/09/backup-and-restore-gitlab-in-docker.html#tar-version it seems the restore recreates the tables.)foo" },
    { "luc4"            , R"foo(which is a problem for me... as the schema in the backup is broken...)foo" },
    { "ToM`"            , R"foo(I feel you... This is why I always keep several backups, and not the last one ^^ Been bit by it)foo" },
    { "luc4"            , R"foo(I have many... the problem is that the database was probably broken many months ago :-()foo" },
    { "luc4"            , R"foo(I didn't notice cause everything works properly until a migration occurs.)foo" },
    { "Unode"           , R"foo(Thanks, found it)foo" },
    { "Unode"           , R"foo(Was already using the Web IDE but that feature was elsewhere. Cheers)foo" },
    { "Unode"           , R"foo(As for the extends I found a ticket in the meantime with discussion going back a few years on how this isn't possible so I'm exploring other options.)foo" },
    { "Unode"           , R"foo(thanks again everyone)foo" },
    { "luc4"            , R"foo(Anyone who knows if it is possible to use pg_dump on the internal gitlab database?)foo" },
    { "Human_G33k"      , R"foo(luc4, you can but it not the best wby)foo" },
    { "Human_G33k"      , R"foo(you should use the gitlab rake command to backup)foo" },
    { "luc4"            , R"foo(I'd need to use --data-only, can I do it with gitlab rake?)foo" },
    { "Human_G33k"      , R"foo(and you will need other things)foo" },
    { "Human_G33k"      , R"foo(like repositories dir, assets and configuration files with secrets.)foo" },
    { "luc4"            , R"foo(I do not want to backup and restore. I only need to recreate the db schema.)foo" },
    { "Human_G33k"      , R"foo(honestly never try, but a pg_dump work)foo" },
    { "Human_G33k"      , R"foo(so do not use --data-only)foo" },
    { "luc4"            , R"foo(I do not want the old schema, which is broken.)foo" },
    { "Human_G33k"      , R"foo(but more schema-only like)foo" },
    { "Human_G33k"      , R"foo(you can reply migration)foo" },
    { "luc4"            , R"foo(my current schema is broken, I only want to dump data.)foo" },
    { "Human_G33k"      , R"foo(*replay)foo" },
    { "luc4"            , R"foo(which migration?)foo" },
    { "Human_G33k"      , R"foo(database migration script)foo" },
    { "luc4"            , R"foo(I do not know when the schema broke.)foo" },
    { "Human_G33k"      , R"foo(but it depend on how your database is broke)foo" },
    { "luc4"            , R"foo(it is badly corrupted.)foo" },
    { "luc4"            , R"foo(by corrupted I mean that it is incoherent internally. I'd need a way to recreate the schema, and then reimporting only data.)foo" },
    { "Human_G33k"      , R"foo(i have the "same issue" on my own debian gitlab instance. WOrkinq on fix it.)foo" },
    { "Human_G33k"      , R"foo(so dump data only and try to insert on the new schema)foo" },
    { "luc4"            , R"foo(:-()foo" },
    { "luc4"            , R"foo(exactly)foo" },
    { "luc4"            , R"foo(that is the solution, but I'm stuck dumping data-only.)foo" },
    { "Human_G33k"      , R"foo(from root)foo" },
    { "Human_G33k"      , R"foo(su postgres)foo" },
    { "Human_G33k"      , R"foo(or not)foo" },
    { "Human_G33k"      , R"foo(you only have to know the database name)foo" },
    { "Human_G33k"      , R"foo(gitlab_production)foo" },
    { "luc4"            , R"foo(gitlabhq_production should be)foo" },
    { "Human_G33k"      , R"foo(from debian package)foo" },
    { "luc4"            , R"foo(I'm in docker, postgres does not exist)foo" },
    { "Human_G33k"      , R"foo(i hate sooo mutch docker)foo" },
    { "Human_G33k"      , R"foo(it s a dev tool not a production one …)foo" },
    { "luc4"            , R"foo(~/my_dump.sql)foo" },
    { "luc4"            , R"foo(this may be near)foo" },
    { "luc4"            , R"foo(failed: FATAL: Peer authentication failed for user)foo" },
    { "Human_G33k"      , R"foo(easy)foo" },
    { "luc4"            , R"foo(maybe I'm missing some password...)foo" },
    { "Human_G33k"      , R"foo(you need to change conf in postgres conf)foo" },
    { "Human_G33k"      , R"foo(something in pg_hda.conf if i remember well)foo" },
    { "luc4"            , R"foo(oh, that I didn't know)foo" },
    { "luc4"            , R"foo(what should I change in there?)foo" },
    { "Human_G33k"      , R"foo(probably your ip or something is not set)foo" },
    { "Human_G33k"      , R"foo(and if there is a need for password it it can be the root cause too i guessx)foo" },
    { "Human_G33k"      , R"foo(not sure there is a password by default)foo" },
    { "Human_G33k"      , R"foo(more a unix socket)foo" },
    { "Human_G33k"      , R"foo(let me check)foo" },
    { "luc4"            , R"foo(unix socket is in /var/opt/gitlab/postgresql)foo" },
    { "luc4"            , R"foo(I'm not sure about the password)foo" },
    { "luc4"            , R"foo(couldn't find if there is a default one)foo" },
    { "Human_G33k"      , R"foo(for me conf is /etc/postgresql/13/main/pg_hba.conf you need to adapt it the conf dir and the version number.)foo" },
    { "Human_G33k"      , R"foo(a line containing local all all peer)foo" },
    { "luc4"            , R"foo(mmh... nothing in there)foo" },
    { "Human_G33k"      , R"foo(can be change to)foo" },
    { "Human_G33k"      , R"foo(local all all trust)foo" },
    { "Human_G33k"      , R"foo(try)foo" },
    { "luc4"            , R"foo(find did not find any file with that name)foo" },
    { "Human_G33k"      , R"foo(in /var/opt/gitlab/postgresql)foo" },
    { "Human_G33k"      , R"foo(its a conf so pretty sure it can be a more generic one (debian make things well))foo" },
    { "luc4"            , R"foo(oh, hba!)foo" },
    { "luc4"            , R"foo(found it)foo" },
    { "Human_G33k"      , R"foo(try the change restart posgresql)foo" },
    { "Human_G33k"      , R"foo(and retry the dump)foo" },
    { "Human_G33k"      , R"foo(also check gitlab-rack sub command)foo" },
    { "luc4"            , R"foo(I'm trying, thanks!)foo" },
    { "Human_G33k"      , R"foo(there is lot of stuff)foo" },
    { "Human_G33k"      , R"foo(for check "repair" existing gitlab instance)foo" },
    { "luc4"            , R"foo(unfortunately nothing changed)foo" },
    { "Human_G33k"      , R"foo(check gitlab conf file the database password should be somewhere)foo" },
    { "luc4"            , R"foo(eh... cannot find where unfortunately)foo" },
    { "luc4"            , R"foo(it seems it was sufficient to log in with the gitlab-psql user)foo" },
    { "luc4"            , R"foo(in case this can be of help to you)foo" },
    { "devslash"        , R"foo(has anyone here taken the gitlab certified associate course offered by gitlab)foo" },
    { "RandomArcher"    , R"foo(Hello everyone, I'm getting a "Access denied" (cloudflare error) when visiting 'gitlab.com' any idea why it's happening?)foo" },
    { "devslash"        , R"foo(when you use a quick action like /spend isnt it supposed to add a label on the issue with the spend time)foo" },
    { "N3X15"           , R"foo(Is there a way to delete a user and their contributions through the API? Some prick is spamming my instance and has whitespace in their name, so I can't confirm the delete via typing in their name)foo" },
    { "certifiable"     , R"foo(https://docs.gitlab.com/ee/api/users.html#user-deletion)foo" },
    { "certifiable"     , R"foo(With hard_delete=>true)foo" },
    { "N3X15"           , R"foo(409)foo" },
    { "N3X15"           , R"foo(gitlab.exceptions.409: User cannot be removed while is the sole-owner of a group)foo" },
    { "N3X15"           , R"foo(Time to make a security email, I guess)foo" },
    { "N3X15"           , R"foo(Ended up being a problem with the Python library I'm using.)foo" },
    { "N3X15"           , R"foo(Apparently they didn't think of passing params to DELETEs)foo" },
    { "IOhannes"        , R"foo(what about the 13.8.2 release?)foo" },
    { "IOhannes"        , R"foo(i so hate it when packages appear in the apt-repositories and there is no changelog/announcement)foo" },
    { "dreamer"         , R"foo(changelog is overrated. you'll find out the new bugs soon enough!)foo" },
    { "whf"             , R"foo(Does anyone here know if there is (or are plans to create) a general,global gitlab events hook..? So externally a pub<->sub system could be setup.., which would retrieve all events from gitlab in a json payload.)foo" },
    { "ikke"            , R"foo(gitlab already supports system hooks)foo" },
    { "whf"             , R"foo(from what i've read, the system hooks are only on "git"-pre-receive, post-receive, update.)foo" },
    { "whf"             , R"foo(https://docs.gitlab.com/ee/administration/server_hooks.html)foo" },
    { "bernard__"       , R"foo(never understood git events)foo" },
    { "queip"           , R"foo(it's a script that runs when ever something happens, like a commit happens)foo" },
    { "queip"           , R"foo(it can afair also decide to outout some message, or to stop given operation from proceeding)foo" },
    { "bernard__"       , R"foo(yeah that part is understandable)foo" },
    { "bernard__"       , R"foo(in regards to CI though.. git-ftp doesn't trigger hooks right?)foo" },
    { "bernard__"       , R"foo(they trigger by using git pull git commit etcetera)foo" },
    { "bernard__"       , R"foo(right?)foo" },
    { "whf"             , R"foo(There are several, bernard__ more info is on https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks .. gitlab uses the three server-side hook that are listed at the end of that page.)foo" },
    { "TomyWork"        , R"foo(I'm trying to remove a kubernetes cluster from a group that i just added there and didn't use for anything. I now clicked on "Remove integration and resources" 2 times now and all that happens is it showing "Kubernetes cluster integration and resources are being removed." at the top. been waiting for 10 minutes now, which is a little excessive for removing nothing :))foo" },
    { "TomyWork"        , R"foo(can i see the progress or logs or something somewhere?)foo" },
    { "bernard__"       , R"foo(danke)foo" },
    { "TomyWork"        , R"foo(ok i found something in the sidekiq dashboard... gcp_cluster:clusters_cleanup_service_account queue has a Clusters::Cleanup::ServiceAccountWorker job that keeps running into a 403)foo" },
    { "TomyWork"        , R"foo(I'm not sure what it's trying to do)foo" },
    { "TomyWork"        , R"foo(according to "kubectl get --all-namespaces serviceaccounts", there's no service account created after the "gitlab" service account that I created about 1.5 hours ago)foo" },
    { "TomyWork"        , R"foo(that's the one i gave to gitlab to use. is it trying to delete that?)foo" },
    { "bernard__"       , R"foo(hm access logs?)foo" },
    { "TomyWork"        , R"foo(i think it's trying to use the company proxy -_-)foo" },
    { "TomyWork"        , R"foo(and that gives me a 403 cause that doesnt have access to internal services for obvious reasons)foo" },
    { "TomyWork"        , R"foo(and it's completely ignoring no_proxy and NO_PROXY)foo" },
    { "TomyWork"        , R"foo(even if i put the fqdn in there, even if i add the port)foo" },
    { "TomyWork"        , R"foo(and yes, i reconfigured and restarted everything)foo" },
    { "TomyWork"        , R"foo(i even checked using procfs if the sidekiq process got the environment variables)foo" },
    { "TomyWork"        , R"foo(net::http, or whatever it uses to wrap that, is broken)foo" },
    { "zumba_addict"    , R"foo(Need help, we can't search a string with spaces. How do we do that?)foo" },
    { "zumba_addict"    , R"foo(wrapping it with double quotes didn't help)foo" },
    { "bernard__"       , R"foo(%20)foo" },
    { "bernard__"       , R"foo(jk)foo" },
    { "zumba_addict"    , R"foo(lol)foo" },
    { "zumba_addict"    , R"foo(so not possible?)foo" },
    { "bernard__"       , R"foo(never found gitlabs search function useful)foo" },
    { "zumba_addict"    , R"foo(To find the exact phrase (stemming still applies), use double "display bug")foo" },
    { "zumba_addict"    , R"foo(i just found out many at work hates the search functionality)foo" },
    { "bernard__"       , R"foo(same)foo" },
    { "D0han"           , R"foo(use grep)foo" },
    { "D0han"           , R"foo(¯_(ツ)_/¯)foo" },
    { "bernard__"       , R"foo(yeah clone all projects and run grep)foo" },
    { "bernard__"       , R"foo(shouldn't take long)foo" },
    { "zumba_addict"    , R"foo(sed may be faster)foo" },
    { "zumba_addict"    , R"foo(but grep is right)foo" },
    { "zumba_addict"    , R"foo(ah, it doesn't like CMakeLists.txt LICENSE README.md build cmake logs.h raw raw-all scripts src third-party wildcard even if they mentioned it in their wiki, LMAO)foo" },
};
